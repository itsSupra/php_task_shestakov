# Задание - выполнить 53 задачи

Оценка по задачам:
* Задачи 1-49 - 49 баллов (за каждую выполненную задачу по 1 баллу)
* Задачи 50-52 - 24 баллов (за каждую выполненную задачу по 8 баллов)
* Задача 53 - 27 баллов

То есть за выполнение всех задач можно получить 100 баллов.

Срок выполнения `уточнить у преподавателя`.
За каждый просроченный день выполнения минус 10 баллов от максимальной оценки. Если задач больше не будет делаться, то нужно сообщить.

Все решения в одном репозитории с названием php_task_<логин>
По каждлй задаче решение должно быть в отдельно директории с названием task_<номер задачи>

## Задача 1
Палиндром — число, слово или текст, одинаково читающееся в обоих направлениях. Например: "радар", "топот".

Реализуйте функцию isPalindrome, которая принимает на вход слово, определяет является ли оно палиндромом и возвращает логическое значение.

Для определения является ли слово палиндромом, достаточно сравнивать попарно символ с обоих концов слова. Если они все равны, то это палиндром. Решите задачу без использования реверса строки.

Примеры использования:

```
<?php

isPalindrome('radar'); // true
isPalindrome('maam'); // true
isPalindrome('a');     // true
isPalindrome('abs');   // false
```

## Задача 2

Реализуйте функцию isPalindrome, которая принимает на вход слово, определяет является ли оно палиндромом и возвращает логическое значение.

В отличии от предыдущей реализации, выполните эту более простым способом, через сравнение исходной строки с ее перевернутой версией. Если они между собой равны, значит это палиндром.

## Задача 3

Реализуйте функцию reverse, которая переворачивает цифры в переданном числе:
```
<?php

use function Number\reverse;

reverse(13); // 31
reverse(-123); // -321
```

Не забудьте задать тип входного и выходного аргумента.

## Задача 4

Реализуйте функцию swap, которая меняет местами переданные аргументы по ссылке.

```
<?php

$a = 5;
$b = 8;
swap($a, $b);

print_r($a); // 8
print_r($b); // 5
```

Дополнительным плюсом будет реализация задачи без использования дополнительных переменных

## Задача 5

Написать функцию, решающую квадратичное уравнение через дискриминант
https://ru.wikipedia.org/wiki/%D0%9A%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F

## Задача 6

Реализуйте функцию get, которая излекает из массива элемент по указанному индексу, если индекс существует, либо возвращает значение по умолчанию. Функция принимает на вход три аргумента:

Массив
Индекс
Значение по умолчанию (которое по умолчанию равно null)
Пример:
```
<?php

use function App\Arrays\get;

$cities = ['moscow', 'london', 'berlin', 'porto'];

get($cities, 1); // => london
get($cities, 4); // => null
get($cities, 10, 'paris'); // => paris
```

## Задача 7

Реализуйте функцию addPrefix, которая добавляет к каждому элементу массива переданный префикс и возвращает получившийся массив. Функция предназначена для работы со строковыми элементами. Аргументы:

Массив
Префикс
После префикса автоматически добавляется пробел.
```
<?php

use function App\Arrays\addPrefix;

$names = ['john', 'smith', 'karl'];

$newNames = addPrefix($names, 'Mr');
print_r($newNames);
// => ['Mr john', 'Mr smith', 'Mr karl'];
```

## Задача 8

Реализуйте функцию swap, которая меняет местами два элемента относительно переданного индекса. Например, если передан индекс 5, то функция меняет местами элементы, находящиеся по индексам 4 и 6.

Параметры функции:

Массив
Индекс
Если хотя бы одного из индексов не существует, функция возвращает исходный массив.
```
<?php

use function App\Arrays\swap;

$names = ['john', 'smith', 'karl'];

$result = swap($names, 1);
print_r($result); // => ['karl', 'smith', 'john']

$result = swap($names, 2);
print_r($result); // => ['john', 'smith', 'karl']
```

## Задача 9

Реализуйте функцию calculateAverage, которая высчитывает среднее арифметическое элементов массива.
```
<?php

$temperatures = [37.5, 34, 39.3, 40, 38.7, 41.5];

calculateAverage($temperatures); // => 38.5
```
    В случае пустого массива функция должна вернуть значение null (используйте в коде для этого guard expression):

```
<?php

$temperatures = [];

calculateAverage($temperatures); // => null
```

## Задача 10

Реализуйте функцию isContinuousSequence, которая проверяет, является ли переданная последовательность целых чисел - возрастающей непрерывно (не имеющей пропусков чисел). Например, последовательность [4, 5, 6, 7] - непрерывная, а [0, 1, 3] - нет. Последовательность может начинаться с любого числа, главное условие - отсутствие пропусков чисел.
```
<?php

isContinuousSequence([10, 11, 12, 13]);     // => true
isContinuousSequence([10, 11, 12, 14, 15]); // => false
isContinuousSequence([1, 2, 2, 3]);         // => false
isContinuousSequence([]);                   // => false
```

## Задача 11

Реализуйте функцию findIndex, которая возвращает первый встретившийся индекс переданного элемента в случае, если элемент присутствует в массиве, и -1 в случае, если он отсутствует.

Параметры функции:

Массив
Элемент
```
<?php

$temperatures = [37.5, 34, 39.3, 40, 38.7, 41.5, 40];

findIndex($temperatures, 34); // => 1
findIndex($temperatures, 40); // => 3
findIndex($temperatures, 3);  // => -1
```


## Задача 12

Реализуйте функцию getSameParity, которая принимает на вход массив чисел и возвращает новый, состоящий из элементов, у которых такая же чётность, как и у первого элемента входного массива.

Примеры
```
<?php

getSameParity([]);        // => []
getSameParity([1, 2, 3]); // => [1, 3]
getSameParity([1, 2, 8]); // => [1]
getSameParity([2, 2, 8]); // => [2, 2, 8]
```
Подсказки
Проверка чётности - остаток от деления: $item % 2 == 0 — чётное число
Если на вход функции передан пустой массив, то она должна вернуть пустой массив. Проверить массив на пустоту можно с помощью функции empty

## Задача 13

Имеется набор данных, описывающих изменение температуры воздуха в одном городе в течение нескольких суток. Данные представлены массивом, в котором каждый элемент - это массив, содержащий список температур в течение одних суток.

Допустим, у нас есть статистика температур (например, по состоянию на утро, день и вечер) за три дня. Для первого дня значения температур составляют: -5°, 7°, 1°; для второго дня: 3°, 2°, 3°; и для третьего дня: -1°, -1°, 10° . Массив, отражающий такую статистику, будет выглядеть так:

```
<?php

$data = [
    [-5, 7, 1],
    [3, 2, 3],
    [-1, -1, 10],
]
```

Реализуйте функцию getIndexOfWarmestDay, которая находит самый тёплый день (тот, в котором была зарегистрирована максимальная температура) и возвращает индекс этого дня в исходном массиве.

```
<?php

$data = [
    [-5, 7, 1],
    [3, 2, 3],
    [-1, -1, 10],
];

getIndexOfWarmestDay($data); // 2
```
Если на вход поступил пустой массив, то функция должна вернуть null

Подсказки
Поиск максимального числа в массиве можно выполнить, используя функцию max

## Задача 14

Реализуйте функцию buildDefinitionList, которая генерирует html список определений (теги dl, dt и dd) и возвращает получившуюся строку.

Параметры функции:

Список определений следующего формата:
```
<?php

$definitions = [
  ['definition1', 'description1'],
  ['definition2', 'description2']
];
```
То есть каждый элемент входного списка сам является массивом, содержащим два элемента: термин и его определение.

Пример:
```
<?php

$definitions = [
    ['Блямба', 'Выпуклость, утолщения на поверхности чего-либо'],
    ['Бобр', 'Животное из отряда грызунов'],
];

buildDefinitionList($definitions);
```

```html
=> '<dl><dt>Блямба</dt><dd>Выпуклость, утолщение на поверхности чего-либо</dd><dt>Бобр</dt><dd>Живтоное из отряда грызунов</dd></dl>';
```

## Задача 15
Реализуйте функцию makeCensored, которая заменяет каждое вхождение указанных слов в предложении на последовательность $#%! и возвращает полученную строку.

Аргументы:
Текст
Набор стоп слов
Словом считается любая непрерывная последовательность символов, включая любые спецсимволы (без пробелов).
```
<?php

use function App\Strings\makeCensored;

$sentence = 'When you play the game of thrones, you win or you die';
makeCensored($sentence, ['die', 'play']);
// => When you $#%! the game of thrones, you win or you $#%!

$sentence2 = 'chicken chicken? chicken! chicken';
makeCensored($sentence2, ['?', 'chicken']);
// => '$#%! chicken? chicken! $#%!';
```


## Задача 16

Реализуйте функцию getSameCount, которая считает количество общих уникальных элементов для двух массивов. Аргументы:

Первый массив
Второй массив
```
<?php

getSameCount([], []); // => 0
getSameCount([1, 10, 3], [10, 100, 35, 1]); // => 2
getSameCount([1, 3, 2, 2], [3, 1, 1, 2]); // => 3
```

## Задача 17
Реализуйте функцию countUniqChars, которая получает на вход строку и считает, сколько символов (уникальных символов) использовано в этой строке. Например, в строке 'yy' всего один уникальный символ — y. А в строке '111yya!' — четыре уникальных символа: 1, y, a и !.

Задание необходимо выполнить без использования функции array_unique.

Примеры
```
<?php

$text1 = 'yyab';
countUniqChars($text1); // => 3

$text2 = 'You know nothing Jon Snow';
countUniqChars($text2); // => 13

$text3 = '';
countUniqChars($text3); // => 0
```

Примечания
Если передана пустая строка, то функция должна вернуть 0, так как пустая строка вообще не содержит символов.

## Задача 18

Реализуйте функцию bubbleSort, которая сортирует массив используя пузырьковую сортировку. Постарайтесь не подглядывать в текст теории и попробуйте воспроизвести алгоритм по памяти.
```
<?php

use function App\Arrays\bubbleSort;

bubbleSort([]); // => []
bubbleSort([3, 10, 4, 3]); // => [3, 3, 4, 10]
```

## Задача 19

Реализуйте функцию checkIfBalanced, которая проверяет балансировку круглых скобок в арифметических выражениях.

```
<?php

checkIfBalanced('(5 + 6) * (7 + 8)/(4 + 3)'); // => true
checkIfBalanced('(4 + 3))'); // => false
```

## Задача 20
Реализуйте функцию getIntersectionForSortedArray, которая принимает на вход два отсортированных массива и находит их пересечение.
Задачу реализовать двумя способами - используя штатные функции, и перебором элементов массивов
```
<?php

getIntersectionOfSortedArray([10, 11, 24], [10, 13, 14, 18, 24, 30]);
// => [10, 24]
```
Подсказки
Не забудьте поставить проверку на размерность массивов. Если хотя бы один из них пустой, то пересечений нет.

## Задача 21

Обратите внимание на сходство json и ассоциативного массива. Оно не случайно. Json является представлением ассоциативного массива в текстовом виде. Composer во время каждого запуска считывает этот файл.

Реализуйте функцию getComposerFileData, которая возвращет ассоциативный массив, соответствующий json из файла composer.json в этом упражнении.


## Задача 22
Обращение к вложенным массивам выглядит просто, только когда мы уверены в наличии всех ключей, попадающихся по пути:
```
<?php

$data = [
    'a' => [
        'b' => [
            'c' => 'wow'
        ]
    ]
];

$data['a']['b']['c']; // => wow
```
Если же наличие данных ключей в массиве не обязательно, тогда код резко усложняется. Каждая попытка обратиться внутрь должна сопровождаться проверкой:
```
<?php

if (array_key_exists('a', $data)) {
    $inner1 = $data['a'];
    if (array_key_exists('b', $inner1)) {
        $inner2 = $inner1['b'];
        if (array_key_exists('c', $inner2)) {
            // ...
        }
    }
}
```

Реализуйте функцию getIn, которая извлекает из массива (который может быть любой глубины вложенности) значение по указанным ключам. Аргументы:

Исходный массив
Массив ключей, по которым ведется поиск значения
В случае, когда добраться до значения невозможно, возвращается null.
```
<?php

$data = [
    'user' => 'ubuntu',
    'hosts' => [
        ['name' => 'web1'],
        ['name' => 'web2']
    ]
];

getIn($data, ['undefined']);        // => null
getIn($data, ['user']);             // => 'ubuntu'
getIn($data, ['user', 'ubuntu']);   // => null
getIn($data, ['hosts', 1, 'name']); // => 'web2'
getIn($data, ['hosts', 0]);         // => ['name' => 'web1']
```

## Задача 23
Реализуйте функцию pick, которая извлекает из переданного массива все элементы по указанным ключам и возвращает новый массив. Аргументы:

Исходный массив
Массив ключей, по которым должны быть выбраны элементы (ключ и значение) из исходного массива, и на основе выбранных данных сформирован новый массив
```
<?php

$data = [
    'user' => 'ubuntu',
    'cores' => 4,
    'os' => 'linux'
];

pick($data, ['user']);       // → ['user' => 'ubuntu']
pick($data, ['user', 'os']); // → ['user' => 'ubuntu', 'os' => 'linux']
pick($data, []);             // → []
pick($data, ['none']);       // → []
```

## Задача 24
Реализуйте функцию genDiff, которая возвращает ассоциативный массив, в котором каждому ключу из исходных массивов соответствует одно из четырёх значений: added, deleted, changed или unchanged. Аргументы:

Ассоциативный массив
Ассоциативный массив
Расшифровка:
```
added — ключ отсутствовал в первом массиве, но был добавлен во второй
deleted — ключ был в первом массиве, но отсутствует во втором
changed — ключ присутствовал и в первом и во втором массиве, но значения отличаются
unchanged — ключ присутствовал и в первом и во втором массиве с одинаковыми значениями
```
```
<?php

use function App\Arrays\genDiff;

$result = genDiff(
    ['one' => 'eon', 'two' => 'two', 'four' => true],
    ['two' => 'own', 'zero' => 4, 'four' => true]
);
// => [
//     'one' => 'deleted',
//     'two' => 'changed'
//     'zero' => 'added',
//     'four' => 'unchanged',
// ];
```

## Задача 25
Реализуйте функцию getSortedNames, которая принимает на вход список пользователей, извлекает их имена, сортирует и возвращает отсортированный список имен.
```
<?php

$users = [
    ['name' => 'Bronn', 'gender' => 'male', 'birthday' => '1973-03-23'],
    ['name' => 'Reigar', 'gender' => 'male', 'birthday' => '1973-11-03'],
    ['name' => 'Eiegon',  'gender' => 'male', 'birthday' => '1963-11-03'],
    ['name' => 'Sansa', 'gender' => 'female', 'birthday' => '2012-11-03']
];

getSortedNames($users); // => ['Bronn', 'Eiegon', 'Reigar', 'Sansa']
```

## Задача 26
Реализуйте набор функций, для работы со словарём, построенным на хеш-таблице. Для простоты, наша реализация не поддерживает разрешение коллизий.

make() — создаёт новый словарь
set($map, $key, $value) — устанавливает в словарь значение по ключу. Работает и для создания и для изменения. Функция возвращает true, если удалось установить значение, и false — в обратной ситуации. Такое возможно при возникновении коллизий.
get($map, $key, $default = null) — читает значение по ключу.
Функции set и get принимают первым параметром словарь и мутируют его. То есть передача идёт по ссылке.

Для полноценного погружения в тему, считаем, что массив в PHP может использоваться только как индексированный массив.
```php
<?php

$map = Map\make();
$result = Map\get($map, 'key');
print_r($result); // => null

$result = Map\get($map, 'key', 'value');
print_r($result); // => value

Map\set($map, 'key2', 'value2');
$result = Map\get($map, 'key2');
print_r($result); // => value2
```

Подсказки
crc32 — хеш-функция
Индекс по которому будет храниться значение во внутреннем массиве вычисляется так: crc32($key) % 1000. То есть к ключу применяется хеш-функция и берется остаток от деления на тысячу. Это нужно для ограничения размера массива в разумных рамках.

## Задача 27
Реализуйте функцию wordsCount, которая считает количество одинаковых слов в предложении. Результатом функции является ассоциативный массив, в ключах которого слова из исходного текста, а значения это количество повторений.

Пример:
```
<?php

wordsCount(''); // []
wordsCount('  one two one'); // ['one' => 2, 'two' => 1]
wordsCount('  one      two       one     '); // ['one' => 2, 'two' => 1]
```

Подсказки
Разбиение строки по разделителю: explode.
Для проверки строки на "пустоту" можно использовать функцию empty.

## Задача 28
Реализовать задачу из задания 27 в консольном варианте принимающем параметр - путь к файлу с текстом Война и Мир. В качестве исходного текста использовать произведение Толстой Лев - Война и мир. 
https://drive.google.com/file/d/1Yvdfc8GkBGo45GZd1KlG6Ko6PTYw_tnT/view?usp=sharing 


## Задача 29
Реализуйте функцию sayPrimeOrNot, которая проверяет переданное число на простоту и печатает на экран yes или no.
```
<?php
sayPrimeOrNot(5); // => yes
sayPrimeOrNot(4); // => no
```
Подсказки

Для этого выделите процесс определения того, является ли число простым, в отдельную функцию, возвращающую логическое значение. Это функция, с помощью которой мы отделяем чистый код от кода, интерпретирующего логическое значение (как 'yes' или 'no') и делающего побочный эффект (печать на экран).

## Задача 30

Реализуйте функцию average, которая возвращает среднее арифметическое всех переданных аргументов. Если функции не передать ни одного аргумента, то она должна вернуть null.
```
<?php

average(0); // => 0
average(0, 10); // => 5
average(-3, 4, 2, 10); // => 3.25
average(); // => null
```

## Задача 31
Реализуйте функцию union, которая находит объединение всех переданных массивов. Функция принимает на вход от одного массива и больше. Ключи исходных массивов не сохраняются (т.е. все значения итогового массива заново индексируются: 0, 1, 2, ...).
```
<?php

union([3]); // => [3]
union([3, 2], [2, 2, 1]); // => [3, 2, 1]
union(['a', 3, false], [true, false, 3], [false, 5, 8]); // => ['a', 3, false, true, 5, 8]
```
## Задача 32
Слаг - часть адреса сайта которая используется для идентификации ресурса в Человекопонятном виде. Без слага /posts/3, со слагом /posts/my-super-post, где слаг это my-super-post. Слаг обычно генерируется автоматически на основе названия ресурса, например статьи.

Реализуйте функцию slugify. Преобразования которые она должна делать:

Приводить к нижнему регистру все символы в строке
Удалять все пробелы
Соединять слова с помощью дефисов
```
<?php

slugify(''); // ''
slugify('test'); // 'test'
slugify('test me'); // 'test-me'
slugify('La La la LA'); // 'la-la-la-la'
slugify('O la      lu'); // 'o-la-lu'
slugify(' yOu   '); // 'you'
```


## Задача 33
Реализуйте анонимную функцию, которая принимает на вход строку и возвращает ее последний символ (или null если строка пустая). Запишите созданную функцию в переменную $last.
```
<?php

$last(''); // => null
$last('pow'); // => w
$last('kids'); // => s
```
## Задача 34

Реализуйте функцию takeOldest, которая принимает на вход список пользователей и возвращает самых взрослых. Количество возвращаемых пользователей задается вторым параметром, который по-умолчанию равен единице.
```
<?php
$users = [
    ['name' => 'Tirion', 'birthday' => '1988-11-19'],
    ['name' => 'Sam', 'birthday' => '1999-11-22'],
    ['name' => 'Rob', 'birthday' => '1975-01-11'],
    ['name' => 'Sansa', 'birthday' => '2001-03-20'],
    ['name' => 'Tisha', 'birthday' => '1992-02-27']
];

takeOldest($users);
# => Array (
#   ['name' => 'Rob', 'birthday' => '1975-01-11']
# )
```
Подсказки
Для преобразования даты в unixtimestamp используйте функцию strtotime

## Задача 35
Реализуйте функцию getChildren, которая принимает на вход список пользователей и возвращает плоский список их детей. Дети каждого пользователя хранятся в виде массива в ключе children
```
<?php

$users = [
    ['name' => 'Tirion', 'children' => [
        ['name' => 'Mira', 'birdhday' => '1983-03-23']
    ]],
    ['name' => 'Bronn', 'children' => []],
    ['name' => 'Sam', 'children' => [
        ['name' => 'Aria', 'birdhday' => '2012-11-03'],
        ['name' => 'Keit', 'birdhday' => '1933-05-14']
    ]],
    ['name' => 'Rob', 'children' => [
        ['name' => 'Tisha', 'birdhday' => '2012-11-03']
    ]],
];

getChildren($users);
// [
//     ['name' => 'Mira', 'birdhday' => '1983-03-23'],
//     ['name' => 'Aria', 'birdhday' => '2012-11-03'],
//     ['name' => 'Keit', 'birdhday' => '1933-05-14'],
//     ['name' => 'Tisha', 'birdhday' => '2012-11-03']
// ]
```

## Задача 36
Реализуйте функцию getGirlFriends, которая принимает на вход список пользователей и возвращает плоский список подруг всех пользователей (без сохранения ключей). Друзья каждого пользователя хранятся в виде массива в ключе friends. Пол доступен по ключу gender и может принимать значения male или female.
```
<?php

$users = [
    ['name' => 'Tirion', 'friends' => [
        ['name' => 'Mira', 'gender' => 'female'],
        ['name' => 'Ramsey', 'gender' => 'male']
    ]],
    ['name' => 'Bronn', 'friends' => []],
    ['name' => 'Sam', 'friends' => [
        ['name' => 'Aria', 'gender' => 'female'],
        ['name' => 'Keit', 'gender' => 'female']
    ]],
    ['name' => 'Rob', 'friends' => [
        ['name' => 'Taywin', 'gender' => 'male']
    ]],
];
```
## Задача 37
Реализуйте функцию getMensCountByYear, которая принимает на вход список пользователей и возвращает массив, в котором ключ это год рождения, а значение это количество мужчин, родившихся в этот год.
```
<?php

$users = [
    ['name' => 'Bronn', 'gender' => 'male', 'birthday' => '1973-03-23'],
    ['name' => 'Reigar', 'gender' => 'male', 'birthday' => '1973-11-03'],
    ['name' => 'Eiegon',  'gender' => 'male', 'birthday' => '1963-11-03'],
    ['name' => 'Sansa', 'gender' => 'female', 'birthday' => '2012-11-03'],
    ['name' => 'Jon', 'gender' => 'male', 'birthday' => '1980-11-03'],
    ['name' => 'Robb','gender' => 'male', 'birthday' => '1980-05-14'],
    ['name' => 'Tisha', 'gender' => 'female', 'birthday' => '2012-11-03'],
    ['name' => 'Rick', 'gender' => 'male', 'birthday' => '2012-11-03'],
    ['name' => 'Joffrey', 'gender' => 'male', 'birthday' => '1999-11-03'],
    ['name' => 'Edd', 'gender' => 'male', 'birthday' => '1973-11-03']
];

getMensCountByYear($users);
# => Array (
#     1973 => 3,
#     1963 => 1,
#     1980 => 2,
#     2012 => 1,
#     1999 => 1
# );
```

Подсказки
Для преобразования даты в Unix Timestamp используйте strtotime.
Для извлечения года из даты используйте функцию date с шаблоном Y.

## Задача 38

Реализуйте функцию getFreeDomainsCount, которая принимает на вход список емейлов, а возвращает количество емейлов, расположенных на каждом бесплатном домене. Список бесплатных доменов хранится в константе FREE_EMAIL_DOMAINS.
```
<?php

$emails = [
    'info@gmail.com',
    'info@yandex.ru',
    'info@hotmail.com',
    'mk@host.com',
    'support@bitrix.com',
    'keys@yandex.ru',
    'sergey@gmail.com',
    'vovan@gmail.com',
    'vovan@hotmail.com'
];

getFreeDomainsCount($emails);
# => Array (
#     'gmail.com' => 3
#     'yandex.ru' => 2
#     'hotmail.com' => 2
#  )
```
## Задача 39

Реализуйте функцию getManWithLessFriends, которая принимает список пользователей и возвращает пользователя, у которого меньше всего друзей.

Примечания
Если список пользователей пустой, то возвращается null
Если в списке есть более одного пользователя с минимальным количеством друзей, то возвращается последний из таких пользователей
Примеры
```
<?php

$users = [
    ['name' => 'Tirion', 'friends' => [
        ['name' => 'Mira', 'gender' => 'female'],
        ['name' => 'Ramsey', 'gender' => 'male']
    ]],
    ['name' => 'Bronn', 'friends' => []],
    ['name' => 'Sam', 'friends' => [
        ['name' => 'Aria', 'gender' => 'female'],
        ['name' => 'Keit', 'gender' => 'female']
    ]],
    ['name' => 'Keit', 'friends' => []],
    ['name' => 'Rob', 'friends' => [
        ['name' => 'Taywin', 'gender' => 'male']
    ]],
];

getManWithLessFriends($users);
// => ['name' => 'Keit', 'friends' => []];
```

## Задача 40
Реализуйте функцию without, функция должна принимать любое число аргументов, где первый аргумент массив, а все остальные - значения, которые нужно исключить из переданного массива.
```
<?php

without([3, 4, 10, 4, 'true'], 4); // => [3, 10, 'true']
without(['3', 2], 0, 5, 11); // => ['3', 2]
```
## Задача 41

Реализуйте функцию getDifference, которая принимает на вход два массива, а возвращает массив, составленный из элементов первого, которых нет во втором.

Эту задачу можно решить с помощью функции array_diff, но подразумевается что вы сделаете это без ее использования.
```
<?php

getDifference([2, 1], [2, 3]);
// → [1]
```

## Задача 42
Реализуйте функцию cd, принимающую на вход два параметра: текущую директорию и путь для перехода. Функция должна вернуть директорию, в которую необходимо перейти.

Пример использования:
```php

<?php

cd('/current/path', '/etc'); // /etc
cd('/current/path', '.././anotherpath'); // /current/anotherpath
```

Правила перехода
Если путь для перехода начинается с /, то он же и является конечным путем (так как абсолютный путь).
.. - на уровень выше
. - та же директория

## Задача 43
Реализуйте функцию rrmdir, удаляющую директорию рекурсивно, то есть вместе со всем своим содержимым.

Подсказка
Одна из возможных реализаций может использовать итераторы.
Воспользуйтесь функцией scandir вместо функции glob.

## Задача 44
еализуйте функцию grep, принимающую на вход два параметра: подстроку для сопоставления и шаблон в формате glob, по которому будет происходить поиск.

Функция должна вернуть список всех строк файлов, в которых содержится подстрока. Поиск должен производиться по всем файлам переданного шаблона.

Пример:
```
<?php

sizeof(grep('test', './*')); // 3
```
## Задача 45
Сериализация — процесс перевода какой-либо структуры данных в последовательность битов. Обратной к операции сериализации является операция десериализации (структуризации) — восстановление начального состояния структуры данных из битовой последовательности.

Функция serialize в php генерирует пригодное для хранения представление переменной. Это полезно для хранения или передачи значений PHP между скриптами без потери их типа и структуры. Для превращения сериализованной строки обратно в PHP-значение существует функция unserialize.

Реализуйте функцию dump, которая принимает на вход имя файла и структуру данных. После чего она сериализует эту структуру и записывает в файл.
Реализуйте функцию load, которая принимает на вход имя файла. После этого она читает содержимое файла и проводит десериализацию.
Пример:
```
    dump($file, $structure);
    load($file);

    $structure == $data;
```

## Задача 46
Написать скрипт рассчета определителя матрицы третьего порядка. Результат не должен быть обернут в функцию

## Задача 47
Написать функцию рассчета определителя матрицы любого порядка начиная со второго. Результат должен быть обернут в функцию. Без использования сторонних библиотек.

## Задача 48
Написать функцию рассчета определителя матрицы любого порядка начиная со второго. Результат должен быть обернут в функцию. С использованием сторонних библиотек.

## Задача 49
Для [диаграммы Венна](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2#/media/%D0%A4%D0%B0%D0%B9%D0%BB:Venn_diagram_showing_Greek,_Latin_and_Cyrillic_letters.svg) букв латинского, греческого и русского алфавита реализовать следующие операции:
- вывести общие буквы для всех трех алфавитов
- вывести буквы, которые встречаются только в греческом и русском алфавитах
- вывести буквы, которые встречаются только в латинском и русском алфавитах
- вывести буквы, которые встречаются только в латинском и греческом алфавитах
- вывести буквы, которые встречаются только в русском алфавите
- вывести буквы, которые встречаются только в латинском алфавите
- вывести буквы, которые встречаются только в греческом алфавите

## Задача 50
Написать функции для получения последовательности [чисел Люка](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%9B%D1%8E%D0%BA%D0%B0)
- итеративно
- рекурсивно
- с использованием генераторов

## Задача 51
Вычислить для последовательности чисел Люка:
- среднее арифметическое
- среднее геометрическое
- среднее гармоническое
- медиану
- моду
- среднее квадратичное отклонение

Последовательность чисел может быть любой.
Без использования сторонних библиотек.

## Задача 52
Вычислить для последовательности чисел Люка:
- среднее арифметическое
- среднее геометрическое
- среднее гармоническое
- медиану
- моду
- среднее квадратичное отклонение

Последовательность чисел может быть любой.
С использованием сторонних библиотек.


## Задача 53
Написать функцию, которая обработает [файлы](https://www3.stats.govt.nz/2018census/Age-sex-by-ethnic-group-grouped-total-responses-census-usually-resident-population-counts-2006-2013-2018-Censuses-RC-TA-SA2-DHB.zip?_ga=2.163769471.1767812132.1605689244-1117244833.1605689244) и выдаст информцию отвечающую на вопрос:
Сколько проживает мужчин и женщин в возрасте от 20 до 40 лет по регионам (Region) следующих национальностей
- European
- Maori
- Pacific Peoples
- Asian
- Middle Eastern/Latin American/African
- New Zealander .

То есть на выходе должна быть таблица выведенная в консоль или cvs файл (за вывод за файл + 5 баллов) содержащая следующие столбцы:
- Пол
- Количество

На каждой строке выводится регион

Огранчиение на выполнение задачи - лимит памяти - 256 Мб
Установить с использованием инструкции
```php
ini_set('memory_limit', '256M');
```

За выполнение задачи 22 баллов, +5 баллов за сохранение результатов в csv-файл.


